# Тестовое задание от Valantis

## Описание веб-приложения

При загрузке страницы будут запращиваться все имеющиеся товары, которые также можно отфильтровать по названию, цене и бренду. Рядом будет input, который подскажет какие данные вводить. После нажатия кнопки поиска будет показана загрузка: красивый на вид скелет пагинации и иконка загрузки.

На каждой странице выводятся 50 товаров.

Можно переключаться между страницами, нажимая нужную страницу ну кнопке пагинации. И не имеет значение как быстро нажимать на пагинацию: старые запросы будут отклоняться.

Снизу слева карточки появляется его номер. Он ни на что не влияет, служит для визуальной идентификации порядка карточки.

Веб-страница полность адаптивна и подходит для мобильных устройств (В стилях использовал стратегию mobile-first).

## .env

в этом файле, расположенном в корне проекта, находятся две переменные:

```
REACT_APP_SERVER_API_URI=
REACT_APP_API_PASSWORD=
```

первая uri сервера, вторая это пароль для запросов.

## С чем столкнулся во время разработки

### Выборка данных

Для выборки данных я решил реализовать единую фукнцию под все actions для api, это позволило мне выбирать только нужный action и добавлять параметры к запросу при создании очередного api метода.
Специальный метод get-auth-password генерирует хэш для авторизации в методе запроса api.

В компоненте app я запрашиваю данные с помощью библиотеки react-query. Это позволило мне избавиться он многого ненужного кода, а также кэшировать данные.

Я старался сделать веб-приложение максимально задумываясь о пользовательском опыте. Было принятно решение использовать AbortController для отмены запроса, если пользователь быстро переключается между страницами в компоненте Pagination.

Я мог бы фильтровать данные на клиенте, так как запрашиваю все идентификаторы (get_ids), но решил воспользоваться также и методом filter в предосталенном api.

### Проблемы с Api и пагинация

- Если не чистить 2 дубликата после возвращенных данных методом get_ids, а потом запросить get_items, то уже будет 4 дубликата.. а если оставить почистить 1 дубликат, то после get_items будет 2 этих же дубликатов. Это довольно странное поведение в api.
- Api не возвращает общее количество товаров. Так как возвращаются дубликаты, то это попросту бесполезно.

Я выбрал запрашивать все идентификаторы, потому что это единственное хорошее решение, так как api возращает дубликаты. После получения данных я их очищаю от дубликатов. Это решение гарантирует что любые данные будут уникальными, чего нельзя добиться при запросах идентификаторов порциями.
Я долго размылшял как запрашивать идентификаторы порциями (get_ids) и пытался реализовать это, но если возвращаются дубликаты, то сделать это нормально не получится.
